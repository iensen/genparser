program(program E) ::= programElement(E)
Stmt(S6) ::= S6
term(T5) ::= T5
program(program E cut_root(P)) ::= programElement(E) program(P)
programElement(V) ::= varDecl(V)
programElement(C) ::= constDef(C)
programElement(F) ::= funcDef(F)
programElement(R) ::= relDef(R)
programElement(T) ::= typeDef(T)
typeDef(typedef I B) ::= identifier(I) ddef typeDefBody(B)
typeDefBody(body T) ::= indefiniteTerm(T)
typeDefBody(body T cut_root(B)) ::= indefiniteTerm(T) pipe typeDefBody(B)
indefiniteTerm(T) ::= term(T)
indefiniteTerm(wherestmt V S) ::= var(V) where Stmt(S)
indefiniteTerm(wherestmt VL S) ::= lparen varList(VL) rparen where Stmt(S)
typeProduct(typeProd T1 T2) ::= type(T1) mult type(T2)
typeProduct(typeProd T1 cut_root(Tp)) ::= type(T1) mult typeProduct(Tp)
type(id_type ID) ::= identifier(ID)
type(prod_type Prod) ::= typeProduct(Prod)
type(set T) ::= Set lparen type(T) rparen
type(list T) ::= List lparen type(T) rparen
type(func T1 T2) ::=  type(T1) map type(T2)
type(part_func T1 T2) ::=  type(T1) partmap type(T2)
decls(decls V T) ::= varList(V) colon type(T)
decls(decls V T cut_root(D)) ::= varList(V) colon type(T) comma decls(D)
varDecl(vardecl V T) ::= var identifier(V) type(T)
varDecl(vardecls D) ::= vars decls(D)
params(params cut_root(VL)) ::= lparen varList(VL) rparen
varList(varList V) ::= identifier(V)
varList(varList V cut_root(VL)) ::= identifier(V) comma varList(VL)
relDef(grelDef G S Ps St) ::= guard(G) identifier(S) params(Ps) iff Stmt(St)
relDef(relDef S Ps St) ::= identifier(S) params(Ps) iff Stmt(St)
relDef(grelDefnoparams G S  St) ::= guard(G) identifier(S)  iff Stmt(St)
relDef(relDefnoparams S St) ::= identifier(S)  iff Stmt(St)
funcDef(gfuncDefw G S Ps B W) ::= guard(G) identifier(S) params(Ps) def funDefBod(B) whereClause(W)
funcDef(gfuncDef G S Ps B) ::= guard(G) identifier(S) params(Ps) def funDefBod(B) 
funcDef(funcDefw S Ps B W) ::= identifier(S) params(Ps) def funDefBod(B) whereClause(W)
funcDef(funcDef S Ps B) ::= identifier(S) params(Ps) def funDefBod(B)
funRHS(rhs F) ::= funDefBod(F)
funRHS(rhs F W ) ::= funDefBod(F) whereClause(W)
funDefBod(body T) ::= term(T)
funDefBod(body B) ::= branches(B)
whereClause(wherecl S) ::= where Stmt(S)
branches(bs F) ::= ifBranches(F)
branches(bso F T) ::= ifBranches(F) semicolon term(T) otherwise
ifBranches(ifs IF) ::= ifBranch(IF)
ifBranches(ifs IF cut_root(IFS)) ::= ifBranch(IF) semicolon ifBranches(IFS)
ifBranch(ifb T S) ::= term(T) if Stmt(S)
constDef(constDef C B) ::= identifier(C) def funRHS(B)
constDef(constDef G C B) ::= guard(G) identifier(C) def funRHS(B)
guard(guard S) ::= If Stmt(S) then
variables(vars V) ::= identifier(V)
variables(vars V Vs) ::= identifier(V) variables(Vs)
S6(S5) ::= S5
S6(eqStmt S5 S6) ::= S5 equivalence S6
S5(S4) ::= S4
S5(implStmt) ::= S4 implies S5
S4(S3) ::= S3
S4(orStmt S4 S3) ::= S4 or S3
S3(S2) ::= S2
S3(andStmt S3 S2) ::= S3 and S2
S2(S1) ::= S1
S2(notStmt S2) ::=  not S2
S1(S0) ::= S0
S1(someStmt V T S1) ::= some identifier(V) in term(T) dot S1
S1(allStmt V T S1) ::= all identifier(V) in term(T) dot S1
S0(defrel S Ts) ::= identifier(S) lparen terms(Ts) rparen
S0(rel P T1 T2) ::= term(T1) infpred(P) term(T2)
S0(defrel S) ::= identifier(S) 
S0(type T Tp) ::= term(T) colon type(Tp)
S0(stmt S) ::= lparen Stmt(S) rparen 
S0(infpred S) ::= infpredString(S) 
infpredString(infpStr T1 P1 T2 P2 T3) ::= term(T1) infpred(P1) term(T2) infpred(P2) term(T3)
infpredString(infpStr T1 P1 cut_root(IS)) ::= term(T1) infpred(P1) infpredString(IS)
infpred(eq) ::= eq
infpred(less) ::= less
infpred(greater) ::= greater
infpred(lessoreq) ::= lessoreq
infpred(greateroreq) ::= greateroreq
infpred(in) ::= in
infpred(subeq) ::= subeq
terms(terms T) ::= term(T)
terms(terms T cut_root(Ts)) ::= term(T) comma terms(Ts)
term(T5) ::= T5
term(lambdaterm Vs T) ::= lambda variables(Vs) dot term(T)
term(vtype T V) ::= type(T) identifier(V)
T5(T4) ::= T4
T5(inf5 T5 T4) ::= T5 infix5 T4
infix5(plus) ::= plus
infix5(minus) ::= minus
infix5(U) ::= U
infix5(backslash) ::= backslash
T4(T3) ::= T3
T4(inf4 T4 T3) ::= T4 infix4 T3
infix4(mult) ::= mult
infix4(div) ::= div
infix4(mod) ::= mod
infix4(nrsec) ::= nrsec
T3(T2) ::= T2
T3(unop P T3) ::= Prefix(P) T3
Prefix(minus) ::= minus
Prefix(plus) ::= plus
Prefix(bigop B S) ::= Bigop(B) lsqparen Stmt(S) rsqparen
Prefix(funct I) ::= identifier(I)
Prefix(floor) ::= floor
Prefix(ceil) ::= ceil
Bigop(Sum) ::= Sum 
Bigop(Prod) ::= Prod
Bigop(Union) ::= Union
Bigop(Nrsec) ::= Nrsec
T2(T1) ::= T1
T2(power T1 T2) ::= T1 hat T2
T1(T0) ::= T0
T1(idx T1 T) ::= T1 lsqparen term(T) rsqparen
T0(id I) ::= identifier(I)
T0(numeral N) ::= numeral(N)
T0(empty_sequence) ::= less greater
T0(sequence Ts) ::= less terms(Ts) greater
T0(tuple T cut_root(Ts)) ::= lparen term(T) comma terms(Ts) rparen
T0(T) ::= lparen term(T) rparen
T0(pipe_term T) ::= pipe term(T) pipe
T0(range T1 T2) ::= lcurparen term(T1) twodots term(T2) rcurparen
T0(pref F Ts) ::= Prefix(F) lparen terms(Ts) rparen
T0(emptySet) ::= lcurparen rcurparen
T0(set Ts) ::= lcurparen terms(Ts) rcurparen
T0(suchthat T S) ::= lcurparen term(T) pipe Stmt(S) rcurparen
T0(single_quoted_string S) ::= single_quoted_string(S)


