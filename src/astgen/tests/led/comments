
Hello, Dr.Rushton.

I have tried to make LED grammar and Tic-Tac-Toe game work on the parser I implemented.


I  was using the input file tttftbV2.led (see attached) that Quinji shared with me.
My grammar is based on the grammar we discussed (see  

In short, it worked, but both the grammar and the game required some changes (see the comments below).
I believe the changes are due to some errors, so I tried to guess how to correct each of the errors.


I was using the following to run the parser:
Lexicon:

Grammar:

Input(the entire tic-tac-toe program):

The tree produced:


The input has 1136 tokens (862 with spaces removed) and the grammar file has 123 rules.
It runs in approximately 38 minutes (2280 seconds) on my computer and uses about 3GB of memory.

(My worst-case prediction was 2000-3000 seconds and 'few gigabytes of memory' for an input up to 1000 tokens and 100 grammar rules).
Apparently I was too optimistic...

But, if you run each defintion separately on the parser - it produces a tree almost immediately.


I think I have some ideas on how to make it more efficient.
1.We can, for example, come up with some heuristics to separate the definitions first.
2.We can use some general ways for doing more efficient backtracking (that may include 1.)
3.We can implement the parser in some other language that allows to produce binary executables (e.g, C/C++/Haskell/SequenceL(?)),
4.I can try a faster computer with a faster operating system whose kernel is optimized for the computer. 
 I believe a lot of time currently is wasted on swapping, because the computer I have has only 4 Gb of RAM.

I believe, all of this together can speed up the computation 30-100 times. In general, I doubt I currently know how to parse something which has more than 10 000 tokens without putting more restrictions on the grammar. But, this is only a guess...

I would be happy to discuss this with you.





Comments on the grammar:

1. The non-terminal 'infpredString' is never used in an RHS of a rule (other than 
the rule which defines it). I don't think this is intended. 

2. According to the grammar I have, 
 boardFull iff 
   all c in cells. occupied(c)
 
is not a valid relation definition.

The problem is that you require parameters of the relation name to be there.
I have changed the rule 

   relDef -> ?guard relsym params iff Stmt 

to 
   relDef -> ?guard relsym ?params iff Stmt 


3. According to the grammar I have,
gameOver iff
    boardFull or threeInRow(x) or threeInRow(o)

is not a valid relation definition.
The problem is that 'boardFull' is not a statement (Stmt).

I changed the rule 

  S0 -> definedRelationSym term | term infpred term | term:type

to
  
  S0 -> definedRelationSym| definedRelationSym term | term infpred term | term:type

In the grammar for my parser I  have 'identifier' instead of 'definedRelationSym'.

4. According to the grammar I have <111> is not a term.
This implies
 oImage(c) :=
  ((centerX(c), centerO(c)), fontSize,<111>)
is not a valid function definition.

I have added <numeral> as one of the possible productions of T0.


5. The rule 
     ifBranches -> ifBranch | ifBranch ifBranches
is missing semicolon between ifBranch and ifBranches.

The rule from tic-tac-toe justifies this claim:

cellDisplay(c) :=
    {xImage(c)} if (`x,c) in Gamma;  
    {oImage(c)} if (`o,c) in Gamma; 
    {}          otherwise
 
I changed the rule to
    ifBranches -> ifBranch | ifBranch ; ifBranches

6.   This statment 

let cellDisplays=
    Union[c in gameBoard] cellDisplay(c)

is strange. You don't have the keyword let in the latest LED syntax draft I have.
And you use := instead of = in all declarations.
I guess this is a constant declaration, so I changed it to

cellDisplays :=
    Union[c in gameBoard] cellDisplay(c)

7. According to the grammar I have, 
 clicked(c) iff 
   (xCoord(click)>xMin(c)) 

this is not a valid relation definition.
The problem is that (Stmt) is not a statement.
I have added a production (Stmt) to the rule for S0.

8.This
movesMade = {(currentPlayer,c) | c in cells & moveMadeIn(c)}
is a strange statement, because it has '=' sign instead of ':='
I guess this is either constant or variable declaration.

I changed the rule to:
movesMade := {(currentPlayer,c) | c in cells & moveMadeIn(c)}

9. In some grammar rules of tic-tac toe game, you have spaces between 
":" and "=" in ":=" symbol. My parser requires one a token not to have 
spaces in between characters. (If you wish to have them, you need to 
write a corresponding regular expression). You can only have spaces between tokens.
This is arguable. 
For now, I removed all spaces between : and = in := symbol.
Please let me know if you have suggestions on this.
 
10. According to the grammar I have, (p,c) is not a term.
I believe it should be a term (or else  
     occupies(p,c) iff (p,c) in Gamma 
is not a valid relation definition!).
 
In the definition of T0, I changed (term) to (terms). 

11. The Tic-Tac toe program contains atoms of the form `identifier (i.e, an   
   identifier preeced by `)
   They are not included into the grammar I have.
   I removed all of the characters ` for now.

12. The Tic-Tac toe program contains atoms of the form "identifier" (i.e, quoted   
   strings)
   They are not included into the grammar I have.
   I removed all of the characters " for now" and replaced each quouted string by an identifier obtain from the string by removing qoutes and all other non-alhphanumeric characters. 


13. You use the word var(vars) for both identifier and the keyword 'var'('vars').
   You have different font to distinguish them, 
             but I cannot use different font in my project.
   Moreover, you sometimes use the full word 'variable' meaning an identifier.
  
   I replaced all occurrences of 'var' and 'variable' which were meant to be   
   identifiers with new lexeme type named 'identifier' and  
   all occurrences of  non-terminal 'vars' with   a new non-terminal name   
   'variables'.





    

