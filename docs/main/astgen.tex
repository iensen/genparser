\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsmath}
\newtheorem{definition}{Definition}
\newtheorem{claim}{Claim}
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{condition}{Condition}
\newtheorem{proposition}{Proposition}

\newtheorem{lemma}{Lemma}
\usepackage{color}
\usepackage{comment}
\usepackage{calrsfs}
\usepackage{latexsym}
\usepackage{mathrsfs}
\usepackage{url}
\usepackage{titlesec}
\usepackage[colorlinks=true]{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=blue
}
\usepackage{alltt}
\usepackage{ulem}
\def\st{\noindent}
\renewcommand\em{\it}
\renewcommand\emph{\textit}
\newcommand\red[1]{{\color{red}#1}}
\newcommand\blue[1]{{\color{blue}#1}}
\newcommand\cancelr[1]{{\color{red}\sout{#1}}}

% define subsubsubsection
\titleclass{\subsubsubsection}{straight}[\subsection]

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}



%\newcommmand{\red}[1]{\textcolor{red}{#1}}
%\renewcommand\red[1]{{\color{red}#1}}
%opening
\title{AST generator specification}
\author{Evgenii Balai}
\def\no{{\bf not}\;}
\begin{document}

\maketitle
\st

\tableofcontents
\section{Vocabulary}

\begin{itemize}
\item \textit{identifier} -  a sequence of alphanumeric or underscore characters starting with a letter.
\item \textit{numeral} - a sequence of characters used to represent a number. Numerals can be in one of the following forms:
\begin{enumerate}
\item $d_1\ldots d_k$
\item $d_1\ldots d_n.d_1\ldots d_m$
\end{enumerate}
possible preceded by a minus sign,
where each $d_i$ is a digit, $k > 0, n\ge 0$ and $m >0$.
\end{itemize}


\section{Input Specification}
The input consists of the following:
\begin{enumerate}
\item lexicon file (defined in section \ref{lf})
\item grammar file (defined in section \ref{gf}) 
\item source file (defined in section \ref{sf})
\end{enumerate}

\subsection{Lexicon file}\label{lf}

A lexicon file is an ASCII file that contains a specification of types of terminal symbols (\textit{lexems}) that may occur in a program file.
Each lexem type is declared as 
\begin{equation}\label{lexdef}
lexem\_type\_name = regex
\end{equation}
where $lexem\_type\_name$ is an identifier and $regex$ is a regular expression following python syntax\cite{pythonre} whose special characters are limited to $.$, $*$, $+$, $?$, $\{m\}$, $\{m,n\}$, $[]$,$\backslash$ or $|$.

We will say that statement (\ref{lexdef}) \textit{defines} a lexem type named $lexem\_type\_name$.

Lexicon file may contain multiple declarations of the form (\ref{lexdef}), one per line, where no lexem type name occurs in the left hand side of a statement more than once, and no lexem type name is a member of the set $\{id, num\}  $.
 
\subsection{Grammar File}\label{gf}
A grammar file is an ASCII file that contains a specification of non-terminals occurring in the produced abstract syntax tree as well as the desired structure of the tree. Every grammar file must be associated with a lexicon file. We will refer to the set of lexem type names defined in the file as $S_L$.  

Non-terminals are specified  by  statements of the form 

\begin{equation}\label{nontd}
nt(\mathcal{L}) = \alpha_1(\tau_1)~\alpha_2(\tau_2)~\ldots~\alpha_n(\tau_n) 
\end{equation}
where 
\begin{enumerate}
\item $nt$ is an identifier which is not a member of the set $\{id,num\}\cup S_L$ sometimes referred to as a \textit{non-terminal name};
\item each $\alpha_i$  is an identifier;
\item each $\tau_i$ is an identifier such that if $i \not=j$, then $\tau_i \not= \tau_j$;
\item $\mathcal{L}$ is a  space-separated sequence  of the form $\beta_1~\ldots~\beta_m$ where
  each  $\beta_i$ except possibly $\beta_1$   
is one of the following forms:
\begin{enumerate}
\item an identifier that is an element of the sequence   $\tau_1\ldots \tau_n$;
\item $f(c)$, where $f$ is a member of the set of identifiers $\{cut\_root\}$ and c is an element of  the sequence   $\tau_1\ldots \tau_n$.
If $f = cut\_root$, $c$ must not be a lexeme type name. 
\end{enumerate} 
 If $\beta_1$ is of one of the forms (a) - (b), then $m$ must be equal to $1$, otherwise $\beta_1$ is an identifier.
\end{enumerate}


We allow a shorthand $\alpha$ that stands for $\alpha(\alpha)$ to be an element of the sequence on the right hand side of the statement (\ref{nontd}). 

A grammar file may contain a sequence of statements of the form (2), one per line, such that
 each $\alpha_i$ is a  non-terminal  name occurring on the left hand side of another statement in the sequence.



\subsection{Source File}\label{sf}
A source file is a file containing arbitrary collection of ASCII characters.

\subsection{Input Examples}\label{ie}
\subsubsection{Arithmetic Expression}
In this example we will define an arithmetic expression whose operands are integer numbers  by means of lexicon and grammar defined in sections \ref{lf} and \ref{gf} and give an example of an arithmetic expression that can be used as contents of a source file.

\subsubsubsection{Lexicon File}\label{alex}
\begin{verbatim}
num = -?([1-9][0-9]+|0)
add_op = \+|-
mult_op = :|\*
left_paren = \(
right_paren = \)
\end{verbatim} 
\subsubsubsection{Grammar File}\label{agram}

\begin{verbatim}
expr(T1) = T1
T1(T2) = T2
T1(add M1 M2) = T2(M1) add_op T1(M2)
T2(mult Op1 Op2) = T3(Op1) mult_op T2(Op2)
T2(T3) = T3
T3(expr) = left_paren expr right_paren
T3(num) = num   
\end{verbatim}
 
\subsubsubsection{Source File}\label{asf}
\begin{verbatim}
1+2*3
\end{verbatim}
\subsubsection{Chess Notation}
In this example we will define Algebraic Chess Notation \cite{chess} by means of lexicon and grammar defined in sections \ref{lf} and \ref{gf} and give an example of a game described in this notation. 
\subsubsubsection{Lexicon file}\label{clex}
\begin{verbatim}
figure = K|Q|R|B|N
file = [a-h]
rank = [1-8]
cell = [a-h][1-8]
capture_char = x
space = \s
spaces = \s+
dot = \.
en_passant = e\.p\.
natural_number = [1-9][0-9]+
move_id = [1-9][0-9]+\.
long_castling = 0-0-0
short_castling = 0-0
plus = \+
pound_sign = #
end = 1-0|1/2-1/2|0-1
\end{verbatim}
\subsubsubsection{Grammar file}\label{cgram}
\begin{verbatim}
game(game move_d) = move_d 
game(game move_d cut_root(G)) = move_d  spaces game(G)
move_d(move move_id M1 M2) = move_id space move(M1) move(M2)
move_d(game_over  move_id move) = move_id space move end
move(pawn_move cell) = cell
move(move figure_spec cell) = figure_spec cell
move(capture figure_spec cell) = figure_spec capture_char cell
move(pawn_capture file cell) = file capture_char cell
move(pawn_special_capture) = file capture_char cell en_passant
move(promotion cell figure) = cell figure
move(castling long_castling) = long_castling
move(castling short_castling) = short_castling
check(check move) = move plus
checkmate(checkmate move) = move pound_sign
figure_spec(fig figure) = figure
figure_spec(fig figure file) = figure file
figure_spec(fig figure file) = figure rank
figure_spec(fig figure cell) = figure cell
\end{verbatim}

\subsubsubsection{Source File}\label{csf}
\begin{comment}
\begin{verbatim}

1. e4 c5 2. Nf3 d6 3. Bb5 Bd7 4. Bxd7 Qxd7 5. c4 Nc6 6. Nc3 Nf6 
7. 0-0 g6 8. d4 cxd4 9. Nxd4 Bg7 10. Nde2 Qe6  11. Nd5 Qxe4 
12. Nc7+ Kd7 13. Nxa8 Qxc4 14. Nb6+ axb6 15. Nc3 Ra8 16. a4 Ne4 
17. Nxe4 Qxe4 18. Qb3 f5 19. Bg5 Qb4 20. Qf7 Be5 21. h3 Rxa4 
22. Rxa4 Qxa4 23. Qxh7 Bxb2 24. Qxg6 Qe4 25. Qf7 Bd4 26. Qb3 f4 
27. Qf7 Be5 28. h4 b5 29. h5 Qc4 30. Qf5+ Qe6 31. Qxe6+ Kxe6 
32. g3 fxg3 33. fxg3 b4 34. Bf4 Bd4 
35. Kh1! b3 36. g4 Kd5 37. g5 e6 38. h6 Ne7 39. Rd1 e5 40. Be3 Kc4 
41. Bxd4 exd4 42. Kg2 b2 43. Kf3 Kc3 44. h7 Ng6 45. Ke4 Kc2 
46. Rh1 d3 47. Kf5 b1=Q 48. Rxb1 Kxb1 49. Kxg6 d2 50. h8=Q d1=Q 
51. Qh7 b5 52. Kf6 Kb2 53. Qh2 Ka1 54. Qf4 b4 55. Qxb4 Qf3+ 
56. Kg7 d5 57. Qd4 Kb1 58. g6 Qe4 59. Qg1 Kb2 60. Qf2+ Kc1 
61. Kf6 d4 62. g7 1-0 
\end{verbatim}
\end{comment}

\begin{verbatim}
1. e4 e5 2. Qh5 Nc6 3. Bc4 Nf6 4. Qxf7# 
\end{verbatim}

\section{Output specification}
The output is obtained in two steps
\begin{enumerate}
\item \textit{Lexing}.  \textit{Lexer Module} takes a source file and lexicon file and outputs a sequence of annotated lexemes as specified in section \ref{lex}.
\item \textit{Parsing}. \textit{Parser Module} takes an output of the lexer module and grammar file as an input and returns an abstract tree as specified in section \ref{pars}.
\end{enumerate}

\subsection{Lexing}\label{lex}
In addition to thee  set of lexeme types  declared in the lexicon file, denoted by $S_L$, we introduce two more lexemes: $id$ and $num$.  For each lexeme $l$, we define a regular expression $\mathcal{R}_L(l)$ as follows:

\begin{enumerate}
\item if $l \in S_L$, $\mathcal{R}_L(l) = expr$, where $expr$ is the regular expression  on the right hand side of the statement
$$l = expr$$
appearing in the lexicon file;
\item if $l$ is $id$, $\mathcal{R}_L(l)$ is 
                               $$[a-z][a-z\_]+$$
\item if $l$ is $num$, $\mathcal{R}_L(l)$ is  
                $$-?[1-9][0-9]+ |-?0\backslash.[0-9]+ | -?[1-9][0-9]+\backslash.[0-9]+$$ 

\end{enumerate}


We will say that a string $S$ \textit{matches} a regular expression $E$ if $S$ is a member of the set of strings specified by  the python regular expression 
$$\wedge E \$ $$
In other words, $S$ matches $E$ if the following python code prints \texttt{True}, when being run on a   python3.4 interpreter:
\begin{alltt}
import re
regex = re.compile(r"^\(E\)$")
print(regex.match("\(S\)") != None)
\end{alltt}

The symbols $\wedge$ and $\$$ are added to $E$ to ensure that the whole string, but not its prefix or suffix are matched. More details on  the syntax and semantics of python regular expressions can be found in \cite{pythonre}.

Let $I$ be the string that represents the contents of the input file. 
The \textit{lexing sequence} of $I$ with respect to the lexicon file $L$ is a sequence of pairs $(l_1,s_1),\ldots (l_n,s_n)$, such that:

\begin{enumerate}
\item each $l_i$ is a lexeme which is a member of the set $S_L \cup \{id,num\}$;
\item each $s_i$ is a string;
\item $s_1+\ldots+s_n$ = $I$ (where + denotes concatenation);
\item for each $1 \le i  \le n$, $s_i$ matches $\mathcal{R}_L(l_i)$;
\item for each $1 \le i \le n$, $s_i$ is the longest prefix of $s_i+\ldots+s_n$ such that $s_i$ matches  $\mathcal{R}_L(l)$ for some  $l \in  S_L \cup \{id,num\}$ 
\end{enumerate}


We will refer to each member of the lexing sequence as an \textit{annotated lexeme}.






\subsection{Parsing}\label{pars}
Given a sequence of annotated lexemes  $(l_1,s_1),\ldots, (l_n,s_n)$ and a sequence $G$ of statements  from a grammar file, the goal of parsing is to produce an abstract syntax tree  as defined in this section. 

By $G_{BNF}$ we denote a BNF grammar obtained from $G$ by 
replacing each statement in $G$ of the form
(\ref{nontd}) with a production rule
\begin{equation*}\label{grule}
nt = \alpha_1~\alpha_2~\ldots~\alpha_n 
\end{equation*}

\st
The symbols of $G_{BNF}$ which are lexeme type names in $G$ are all and only terminal symbols of $G_{BNF}$.

\st Let $\mathcal{T}$ be  a  derivation tree for $l_1\ldots l_n$ in $G_{BNF}$,  where  the starting symbol of the derivation  is the non-terminal occurring in the left hand side of the first statement in $G$. We will say that $\mathcal{T}_1$ is a \textit{subtree} of $\mathcal{T}$ if $\mathcal{T}_1$  a derivation tree whose nodes are a node $n$ in $\mathcal{T}$ and  all of $n$'s descendants in $\mathcal{T}$ and whose edges are all edges of $\mathcal{T}$ connecting a pair of nodes of $\mathcal{T}_1$. 

For each node $N$ of $\mathcal{T}$ by $R_{N}$ we denote a production rule of $G_{BNF}$  that was applied to expand $N$ in $\mathcal{T}$.
We will also say that the statement of $G$ 
$$nt(\beta_1,\ldots,\beta_m) = \alpha_1(\tau_1)~\alpha_2(\tau_2)~\ldots~\alpha_n(\tau_n)$$
\textit{corresponds to $N$}  if it was used to obtain $R_{N}$.


Let $N$ be a node of $\mathcal{T}$ and, if $N$ is not a leaf node of $\mathcal{T}$, let 
$$nt(\beta_1,\ldots,\beta_m) = \alpha_1(\tau_1)~\alpha_2(\tau_2)~\ldots~\alpha_n(\tau_n)$$
be the statement of $G$ corresponding to $N$.

For a sequence $\beta_{b_1}, \ldots, \beta_{b_t}$ such that $\{\beta_{b_1}, \ldots, \beta_{b_t}\} \subseteq \{\beta_1,\ldots, \beta_m\}$ and each $\beta_{b_i} \in \{\beta_{b_1}, \ldots, \beta_{b_t}\}$ is either a member of $\{\tau_1, \ldots, \tau_n\}$ or is of the form $f(c)$ where c is a member of $\{\tau_1, \ldots, \tau_n\}$, by 
$A(\tau_{p_1}, \ldots, \tau_{p_t})$ we denote a sequence of derivation trees defined as follows: 
\begin{enumerate}
\item if $t=1$ and  $\beta_{p_1} = \tau_i$ for some $1 \le i \le n$, $A(\tau_{p_1})$ is a sequence containing one element which is a subtree of $\mathcal{T}$ rooted at  $i^{th}$ child of $N$.
\item if $t=1$ and  $\beta_{p_1} = cut\_root(\tau_i)$ for some $1 \le i \le n$, $A(\tau_{p_1})$ is a sequence of  trees whose $j^{th}$ element is a subtree of $\mathcal{T}$  rooted at  $j^{th}$ child of the $i^{th}$ child of $N$.
\item if $t>1$,  $A(\tau_{p_1}, \ldots, \tau_{p_t})$ is a sequence obtained by concatenating the sequences $A(\tau_{p_1}),\ldots,A(\tau_{p_t})$.
\end{enumerate} 

The \textit{abstract syntax tree corresponding to $N$} is defined as follows:

\begin{enumerate}
\item if $N$ is a leaf of $\mathcal{T}$ labeled with $l_i$, the abstract syntax tree is a tree whose only node is labeled with the pair $(l_i,s_i)$;

\item if $N$ is not a leaf of $\mathcal{T}$, and $\beta_1=\tau_i$ for some $1\le i\le$ the abstract syntax tree is the tree corresponding to the $i^{th}$ child of $N$ (from left to right) in $\mathcal{T}$;

\item if $N$ is not a leaf of $\mathcal{T}$  and $\beta_1\not=\tau_i$ for all $1\le i\le$, the abstract syntax tree is defined as follows:
\begin{enumerate}
\item the root $r$ of the tree is labeled by $\beta_1$;
\item the children of $r$(from left to right) are roots of the trees $\mathcal{T}_1, \ldots \mathcal{T}_k$, where $k = |A(\beta_2,\ldots,\beta_m)|$ and for each $1 \le i\le k$,  $\mathcal{T}_i$ is an abstract syntax tree corresponding to the i-th element of $A(\beta_2,\ldots,\beta_m)$.
\end{enumerate}
 
\end{enumerate}

The result of the parsing is defined to be the abstract syntax tree corresponding to the root of $\mathcal{T}$.  


\subsection{Representation of trees as lists}
Let $T$ be an abstract syntax tree.
In the implementation, $T$ is  represented by a list as follows:
\begin{enumerate}
\item if $T$ is empty, it is represented by an empty lists
\item it $T$ consists of only one node labeled by $r$, the corresponding list is $[r]$
\item if a tree consists of more then one node, it is represented by the list $[r,t_1,\ldots,t_n]$, where $r$ is a label of the root of $T$ and  $t_i$ represents the subtree of $T$ rooted at $i^{th}$ child of $T$ 
\end{enumerate}

\subsection{Examples}
\subsubsection{Arithmetic Expression Tree}

The lexing sequence for the  lexicon file given in section \ref{alex} and source file given in section \ref{asf} is:
\begin{verbatim}
(num '1'), (add_op, '+'), (num, '2'), (mult_op,'*'), (num, '3') 
\end{verbatim}

Given the grammar file in section \ref{agram}, the corresponding abstract syntax tree is represented by the list:
\begin{verbatim}
[add, (num,'1'),[mult,(num,'2'),(num,'3')]]
\end{verbatim}
\subsubsection{Chess Game Tree}

The lexing sequence for the  lexicon file given in section \ref{clex} and source file given in section \ref{csf} is:

\begin{verbatim}
(move_id, '1.'), (space, ' '), (cell, 'e4'), (space, ' '), 
(cell, 'e5'), (spaces, ' '), (move_id, '2.'), (space, ' '), 
(figure, 'Q'), (cell, 'h5'), (space, ' '), (figure, 'B'),
(cell, 'c6'), (spaces, ' '), (move_id, '3.'), (space, ' '), 
(figure, 'B'), (cell, 'c4'), (space, ' '),  (figure, 'N'), 
(cell, 'f6'), (spaces, ' '), (move_id, '4.'), (space, ' '), 
(figure, 'Q'), (capture_char, 'x'), (cell, 'f7'),  
(pound_sign, '#')
\end{verbatim} 

\st
Given the grammar file in section \ref{cgram}, the corresponding abstract syntax tree  is represented by the list:

\begin{verbatim}
[ game,
      [move, [(move_id '1.')], [pawn_move [(cell 'e4')] ], 
                                [pawn_move [(cell 'e5')] ] ],
       
      [move, [(move_id '2.')], [move [fig [(figure 'Q')]] 
                                     [(cell 'h5')] ], 
                                     [move, [fig [(figure 'N')]], 
                                     [(cell 'c6')]]],
           
      [move, [(move_id '3.')], [move [fig [(figure 'B')]],
                                               [(cell 'c4')] ], 
                                         [move, [fig [(figure 'N') ]], 
                                         [(cell 'f6')]]],
               
      [checkmate   [move, [(move_id '4.')],
                                       [capture [fig [(figure 'Q')] ], 
                                       [(cell 'f7')] ] ] ]
               
]
\end{verbatim}



   
\bibliography{mylib}
\bibliographystyle{plain}
\end{document}
